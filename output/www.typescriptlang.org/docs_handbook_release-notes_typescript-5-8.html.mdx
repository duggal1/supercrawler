---
title: Page Content
description: Extracted content from webpage
keywords: web, crawl, content
---

# Type 5.8

## Granular Checks for Branches in Return Expressions

## Support for  require()  of ECMA Modules in  --module nodenext

## --module node18

## The  --erasableSyntaxOnly  Option

## The  --libReplacement  Flag

## Preserved Computed Property Names in Declaration Files

## Optimizations on Program Loads and Updates

## Notable Behavioral Changes

### lib.d.ts

### Restrictions on Import Assertions Under  --module nodenext

### Customize

### Popular Documentation Pages

### Using Type

### Community

##### On this page

##### Is this page helpful?

Was this page helpful?

Consider some code like the following:

The intent of this code is to retrieve a URL object from a cache if it exists, or to create a new URL object if it doesn’t.
However, there’s a bug: we forgot to actually construct a new URL object with the input.
Unfortunately, Type generally didn’t catch this sort of bug.

When Type checks conditional expressions like  cond ? trueBranch : falseBranch , its type is treated as a union of the types of the two branches.
In other words, it gets the type of  trueBranch  and  falseBranch , and combines them into a union type.
In this case, the type of  untypedCache.get(urlString)  is  any , and the type of  urlString  is  string .
This is where things go wrong because  any  is so infectious in how it interacts with other types.
The union  any | string  is simplified to  any , so by the time Type starts checking whether the expression in our  return  statement is compatible with the expected return type of  URL , the type system has lost any information that would have caught the bug in this code.

In Type 5.8, the type system special-cases conditional expressions directly inside  return  statements.
Each branch of the conditional is checked against the declared return type of the containing functions (if one exists), so the type system can catch the bug in the example above.

This change was made  within this pull request , as part of a broader set of future improvements for Type.

For years, Node.js supported ECMA modules (ESM) alongside CommonJS modules.
Unfortunately, the interoperability between the two had some challenges.

In other words, consuming CommonJS files from ESM files was possible, but not the other way around.
This introduced many challenges for library authors who wanted to provide ESM support.
These library authors would either have to break compatibility with CommonJS users, “dual-publish” their libraries (providing separate entry-points for ESM and CommonJS), or just stay on CommonJS indefinitely.
While dual-publishing might sound like a good middle-ground, it is a complex and error-prone process that also roughly doubles the amount of code within a package.

Node.js 22 relaxes some of these restrictions and permits  require("esm")  calls from CommonJS modules to ECMA modules.
Node.js still does not permit  require()  on ESM files that contain a top-level  await , but most other ESM files are now consumable from CommonJS files.
This presents a major opportunity for library authors to provide ESM support without having to dual-publish their libraries.

Type 5.8 supports this behavior under the  --module nodenext  flag.
When  --module nodenext  is enabled, Type will avoid issuing errors on these  require()  calls to ESM files.

Because this feature may be back-ported to older versions of Node.js, there is currently no stable  --module nodeXXXX  option that enables this behavior;
however, we predict future versions of Type may be able to stabilize the feature under  node20 .
In the meantime, we encourage users of Node.js 22 and newer to use  --module nodenext , while library authors and users of older Node.js versions should remain on  --module node16  (or make the minor update to  --module node18 ).

For more information,  see our support for require(“esm”) here .

Type 5.8 introduces a stable  --module node18  flag.
For users who are fixed on using Node.js 18, this flag provides a stable point of reference that does not incorporate certain behaviors that are in  --module nodenext .
Specifically:

See more at both  the  --module node18  pull request  and  changes made to  --module nodenext .

Recently, Node.js 23.6 unflagged  experimental support for running Type files directly ;
however, only certain constructs are supported under this mode.
Node.js has unflagged a mode called  --experimental-strip-types  which requires that any Type-specific syntax cannot have runtime semantics.
Phrased differently, it must be possible to easily  erase  or “strip out” any Type-specific syntax from a file, leaving behind a valid Java file.

That means constructs like the following are not supported:

Here are some examples of what does not work:

Similar tools like  ts-blank-space  or  Amaro  (the underlying library for type-stripping in Node.js) have the same limitations.
These tools will provide helpful error messages if they encounter code that doesn’t meet these requirements, but you still won’t find out your code doesn’t work until you actually try to run it.

That’s why Type 5.8 introduces the  --erasableSyntaxOnly  flag.
When this flag is enabled, Type will error on most Type-specific constructs that have runtime behavior.

Typically, you will want to combine this flag with the  --verbatimModuleSyntax , which ensures that a module contains the appropriate import syntax, and that import elision does not take place.

For more information,  see the implementation here .

In Type 4.5, we introduced the possibility of substituting the default  lib  files with custom ones.
This was based on the possibility of resolving a library file from packages named  @type/lib-* .
For example, you could lock your  dom  libraries onto a specific version of  the  @types/web  package  with the following  package.json :

When installed, a package called  @type/lib-dom  should exist, and Type will currently always look it up when  dom  is implied by your settings.

This is a powerful feature, but it also incurs a bit of extra work.
Even if you’re not using this feature, Type always performs this lookup, and has to watch for changes in  node_modules  in case a  lib -replacement package  begins  to exist.

Type 5.8 introduces the  --libReplacement  flag, which allows you to disable this behavior.
If you’re not using  --libReplacement , you can now disable it with  --libReplacement false .
In the future  --libReplacement false  may become the default, so if you currently rely on the behavior you should consider explicitly enabling it with  --libReplacement true .

For more information,  see the change here .

In an effort to make computed properties have more predictable emit in declaration files, Type 5.8 will consistently preserve entity names ( bareVariables  and  dotted.names.that.look.like.this ) in computed property names in classes.

For example, consider the following code:

Previous versions of Type would issue an error when generating a declaration file for this module, and a best-effort declaration file would generate an index signature.

In Type 5.8, the example code is now allowed, and the emitted declaration file will match what you wrote:

Note that this does not create statically-named properties on the class.
You’ll still end up with what is effectively an index signature like  [x: string]: number , so for that use case, you’d need to use  unique symbol s or literal types.

Note that writing this code was and currently is an error under the  --isolatedDeclarations  flag;
but we expect that thanks to this change, computed property names will generally be permitted in declaration emit.

Note that it’s possible (though unlikely) that a file compiled in Type 5.8 may generate a declaration file that is not backward compatible in Type 5.7 or earlier.

For more information,  see the implementing PR .

Type 5.8 introduces a number of optimizations that can both improve the time to build up a program, and also to update a program based on a file change in either  --watch  mode or editor scenarios.

First, Type now  avoids array allocations that would be involved while normalizing paths .
Typically, path normalization would involve segmenting each portion of a path into an array of strings, normalizing the resulting path based on relative segments, and then joining them back together using a canonical separator.
For projects with many files, this can be a significant and repetitive amount of work.
Type now avoids allocating an array, and operates more directly on indexes of the original path.

Additionally, when edits are made that don’t change the fundamental structure of a project,  Type now avoids re-validating the options provided to it  (e.g. the contents of a  tsconfig.json ).
This means, for example, that a simple edit might not require checking that the output paths of a project don’t conflict with the input paths.
Instead, the results of the last check can be used.
This should make edits in large projects feel more responsive.

This section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade.
Sometimes it will highlight deprecations, removals, and new restrictions.
It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.

Types generated for the DOM may have an impact on type-checking your codebase.
For more information,  see linked issues related to DOM and  lib.d.ts  updates for this version of Type .

Import assertions were a proposed addition to ECMA to ensure certain properties of an import (e.g. “this module is JSON, and is not intended to be executable Java code”).
They were reinvented as a proposal called  import attributes .
As part of the transition, they swapped from using the  assert  keyword to using the  with  keyword.

Node.js 22 no longer accepts import assertions using the  assert  syntax.
In turn when  --module nodenext  is enabled in Type 5.8, Type will issue an error if it encounters an import assertion.

For more information,  see the change here

The Type docs are an open source project. Help us improve these pages  by sending a Pull Request  ❤

Last updated: Apr 09, 2025

Site Colours :

Code Font :

All of the common types in Type

Techniques to make more elegant types

How to provide types to functions in Java

How to provide a type shape to Java objects

How Type infers types based on runtime behavior

How to create and type Java variables

An overview of building a Type web app

All the configuration options for a project

How to provide types to Java ES6 classes

Made with ♥ in Redmond, Boston, SF & Dublin

© 2012- 2025  Microsoft Privacy Terms of Use

MSG

- Download
- Docs
- Handbook
- Community
- Playground
- Tools

- Get Started TS for the New Programmer Type for JS Programmers TS for Java/C# Programmers TS for Functional Programmers Type Tooling in 5 minutes
- TS for the New Programmer
- Type for JS Programmers
- TS for Java/C# Programmers
- TS for Functional Programmers
- Type Tooling in 5 minutes
- Handbook The Type Handbook The Basics Everyday Types Narrowing More on Functions Object Types Type Manipulation Creating Types from Types Generics Keyof Type Operator Typeof Type Operator Indexed Access Types Conditional Types Mapped Types Template Literal Types Classes Modules
- The Type Handbook
- The Basics
- Everyday Types
- Narrowing
- More on Functions
- Object Types
- Type Manipulation Creating Types from Types Generics Keyof Type Operator Typeof Type Operator Indexed Access Types Conditional Types Mapped Types Template Literal Types
- Creating Types from Types
- Generics
- Keyof Type Operator
- Typeof Type Operator
- Indexed Access Types
- Conditional Types
- Mapped Types
- Template Literal Types
- Classes
- Modules
- Reference Utility Types Cheat Sheets Decorators Declaration Merging Enums Iterators and Generators JSX Mixins Namespaces Namespaces and Modules Symbols Triple-Slash Directives Type Compatibility Type Inference Variable Declaration
- Utility Types
- Cheat Sheets
- Decorators
- Declaration Merging
- Enums
- Iterators and Generators
- JSX
- Mixins
- Namespaces
- Namespaces and Modules
- Symbols
- Triple-Slash Directives
- Type Compatibility
- Type Inference
- Variable Declaration
- Modules Reference Introduction Theory Guides Choosing Compiler Options Reference Appendices ESM/CJS Interoperability
- Introduction
- Theory
- Guides Choosing Compiler Options
- Choosing Compiler Options
- Reference
- Appendices ESM/CJS Interoperability
- ESM/CJS Interoperability
- Tutorials ASP.NET Core Gulp DOM Manipulation Migrating from Java Using Babel with Type
- ASP.NET Core
- Gulp
- DOM Manipulation
- Migrating from Java
- Using Babel with Type
- What's New Type 5.8 Type 5.7 Type 5.6 Type 5.5 Type 5.4 Type 5.3 Type 5.2 Type 5.1 Type 5.0 Type 4.9 Type 4.8 Type 4.7 Type 4.6 Type 4.5 Type 4.4 Type 4.3 Type 4.2 Type 4.1 Type 4.0 Type 3.9 Type 3.8 Type 3.7 Type 3.6 Type 3.5 Type 3.4 Type 3.3 Type 3.2 Type 3.1 Type 3.0 Type 2.9 Type 2.8 Type 2.7 Type 2.6 Type 2.5 Type 2.4 Type 2.3 Type 2.2 Type 2.1 Type 2.0 Type 1.8 Type 1.7 Type 1.6 Type 1.5 Type 1.4 Type 1.3 Type 1.1
- Type 5.8
- Type 5.7
- Type 5.6
- Type 5.5
- Type 5.4
- Type 5.3
- Type 5.2
- Type 5.1
- Type 5.0
- Type 4.9
- Type 4.8
- Type 4.7
- Type 4.6
- Type 4.5
- Type 4.4
- Type 4.3
- Type 4.2
- Type 4.1
- Type 4.0
- Type 3.9
- Type 3.8
- Type 3.7
- Type 3.6
- Type 3.5
- Type 3.4
- Type 3.3
- Type 3.2
- Type 3.1
- Type 3.0
- Type 2.9
- Type 2.8
- Type 2.7
- Type 2.6
- Type 2.5
- Type 2.4
- Type 2.3
- Type 2.2
- Type 2.1
- Type 2.0
- Type 1.8
- Type 1.7
- Type 1.6
- Type 1.5
- Type 1.4
- Type 1.3
- Type 1.1
- Declaration Files Introduction Declaration Reference Library Structures .d.ts Templates Modules .d.ts Module: Plugin Module: Class Module: Function Global .d.ts Global: Modifying Module Do's and Don'ts Deep Dive Publishing Consumption
- Introduction
- Declaration Reference
- Library Structures
- .d.ts Templates Modules .d.ts Module: Plugin Module: Class Module: Function Global .d.ts Global: Modifying Module
- Modules .d.ts
- Module: Plugin
- Module: Class
- Module: Function
- Global .d.ts
- Global: Modifying Module
- Do's and Don'ts
- Deep Dive
- Publishing
- Consumption
- Java JS Projects Utilizing Type Type Checking Java Files JSDoc Reference Creating .d.ts Files from .js files
- JS Projects Utilizing Type
- Type Checking Java Files
- JSDoc Reference
- Creating .d.ts Files from .js files
- Project Configuration What is a tsconfig.json Compiler Options in MSBuild TSConfig Reference tsc CLI Options Project References Integrating with Build Tools Configuring Watch Nightly Builds
- What is a tsconfig.json
- Compiler Options in MSBuild
- TSConfig Reference
- tsc CLI Options
- Project References
- Integrating with Build Tools
- Configuring Watch
- Nightly Builds

- TS for the New Programmer
- Type for JS Programmers
- TS for Java/C# Programmers
- TS for Functional Programmers
- Type Tooling in 5 minutes

- The Type Handbook
- The Basics
- Everyday Types
- Narrowing
- More on Functions
- Object Types
- Type Manipulation Creating Types from Types Generics Keyof Type Operator Typeof Type Operator Indexed Access Types Conditional Types Mapped Types Template Literal Types
- Creating Types from Types
- Generics
- Keyof Type Operator
- Typeof Type Operator
- Indexed Access Types
- Conditional Types
- Mapped Types
- Template Literal Types
- Classes
- Modules

- Creating Types from Types
- Generics
- Keyof Type Operator
- Typeof Type Operator
- Indexed Access Types
- Conditional Types
- Mapped Types
- Template Literal Types

- Utility Types
- Cheat Sheets
- Decorators
- Declaration Merging
- Enums
- Iterators and Generators
- JSX
- Mixins
- Namespaces
- Namespaces and Modules
- Symbols
- Triple-Slash Directives
- Type Compatibility
- Type Inference
- Variable Declaration

- Introduction
- Theory
- Guides Choosing Compiler Options
- Choosing Compiler Options
- Reference
- Appendices ESM/CJS Interoperability
- ESM/CJS Interoperability

- Choosing Compiler Options

- ESM/CJS Interoperability

- ASP.NET Core
- Gulp
- DOM Manipulation
- Migrating from Java
- Using Babel with Type

- Type 5.8
- Type 5.7
- Type 5.6
- Type 5.5
- Type 5.4
- Type 5.3
- Type 5.2
- Type 5.1
- Type 5.0
- Type 4.9
- Type 4.8
- Type 4.7
- Type 4.6
- Type 4.5
- Type 4.4
- Type 4.3
- Type 4.2
- Type 4.1
- Type 4.0
- Type 3.9
- Type 3.8
- Type 3.7
- Type 3.6
- Type 3.5
- Type 3.4
- Type 3.3
- Type 3.2
- Type 3.1
- Type 3.0
- Type 2.9
- Type 2.8
- Type 2.7
- Type 2.6
- Type 2.5
- Type 2.4
- Type 2.3
- Type 2.2
- Type 2.1
- Type 2.0
- Type 1.8
- Type 1.7
- Type 1.6
- Type 1.5
- Type 1.4
- Type 1.3
- Type 1.1

- Introduction
- Declaration Reference
- Library Structures
- .d.ts Templates Modules .d.ts Module: Plugin Module: Class Module: Function Global .d.ts Global: Modifying Module
- Modules .d.ts
- Module: Plugin
- Module: Class
- Module: Function
- Global .d.ts
- Global: Modifying Module
- Do's and Don'ts
- Deep Dive
- Publishing
- Consumption

- Modules .d.ts
- Module: Plugin
- Module: Class
- Module: Function
- Global .d.ts
- Global: Modifying Module

- JS Projects Utilizing Type
- Type Checking Java Files
- JSDoc Reference
- Creating .d.ts Files from .js files

- What is a tsconfig.json
- Compiler Options in MSBuild
- TSConfig Reference
- tsc CLI Options
- Project References
- Integrating with Build Tools
- Configuring Watch
- Nightly Builds

- ESM files could  import  CommonJS files
- CommonJS files  could not   require()  ESM files

- require()  of ECMA modules is disallowed under  node18 , but allowed under  nodenext
- import assertions (deprecated in favor of import attributes) are allowed under  node18 , but are disallowed under  nodenext

- enum  declarations
- namespace s and  module s with runtime code
- parameter properties in classes
- Non-ECMA  import =  and  export =  assignments

- Granular Checks for Branches in Return Expressions
- Support for require() of ECMA Modules in --module nodenext
- --module node18
- The --erasableSyntaxOnly Option
- The --libReplacement Flag
- Preserved Computed Property Names in Declaration Files
- Optimizations on Program Loads and Updates
- Notable Behavioral Changes lib.d.ts Restrictions on Import Assertions Under --module nodenext
- lib.d.ts
- Restrictions on Import Assertions Under --module nodenext

- lib.d.ts
- Restrictions on Import Assertions Under --module nodenext

- Everyday Types All of the common types in Type
- Creating Types from Types Techniques to make more elegant types
- More on Functions How to provide types to functions in Java
- More on Objects How to provide a type shape to Java objects
- Narrowing How Type infers types based on runtime behavior
- Variable Declarations How to create and type Java variables
- Type in 5 minutes An overview of building a Type web app
- TSConfig Options All the configuration options for a project
- Classes How to provide types to Java ES6 classes

- Get Started
- Download
- Community
- Playground
- TSConfig Ref
- Code Samples
- Why Type
- Design

- Get Help
- Blog
- GitHub Repo
- Community Chat
- @Type
- Mastodon
- Stack Overflow
- Web Repo